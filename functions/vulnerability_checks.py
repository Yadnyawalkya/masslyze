import datetime

def check_for_sslv3(db_cursor, db_connection, host_ip, host_port, vulnerability):
    if vulnerability.get('isProtocolSupported') == "True":
        db_cursor.execute('''UPDATE hosts SET sslv3=? WHERE ip=? AND port=?''', (True, host_ip, host_port))
        #db_connection.commit()

def check_for_sslv2(db_cursor, db_connection, host_ip, host_port, vulnerability):
    if vulnerability.get('isProtocolSupported') == "True":
        db_cursor.execute('''UPDATE hosts SET sslv2=? WHERE ip=? AND port=?''', (True, host_ip, host_port))
        #db_connection.commit()

def check_for_crime(db_cursor, db_connection, host_ip, host_port, vulnerability):
    compression_method = vulnerability.find('compressionMethod')
    if compression_method.get('isSupported') == "True":
        db_cursor.execute('''UPDATE hosts SET CRIME=? WHERE ip=? AND port=?''', (True, host_ip, host_port))
        #db_connection.commit()

def check_for_heartbleed(db_cursor, db_connection, host_ip, host_port, vulnerability):
    # check if sslyze failed (exception) during scan
    if vulnerability.get('title') == "PluginHeartbleed":
        return
    openssl_heartbleed = vulnerability.find('openSslHeartbleed')
    if openssl_heartbleed.get('isVulnerable') == "True":
        db_cursor.execute('''UPDATE hosts SET heartbleed=? WHERE ip=? AND port=?''', (True, host_ip, host_port))
        #db_connection.commit()

def check_for_reneg(db_cursor, db_connection, host_ip, host_port, vulnerability):
    # check if sslyze failed (exception) during scan
    if vulnerability.get('title') == "PluginSessionRenegotiation":
        return
    reneg = vulnerability.find('sessionRenegotiation')
    if reneg.get('canBeClientInitiated') == "True":
        db_cursor.execute('''UPDATE hosts SET reneg=? WHERE ip=? AND port=?''', (True, host_ip, host_port))
        #db_connection.commit()

def check_for_certificate(db_cursor, db_connection, host_ip, host_port, vulnerability):
    certificate_problems = ""
    # certificate hostname + trust
    certificate_validation = vulnerability.find('certificateValidation')
    hostname_validation = certificate_validation.find('hostnameValidation')
    if hostname_validation.get('certificateMatchesServerHostname') == "False":
        certificate_problems = certificate_problems + "| certificate does not match server hostname |"
    path_validation = certificate_validation.findall('pathValidation')
    for truststore in path_validation:
        if truststore.get('validationResult') != "ok":
            certificate_problems = certificate_problems + "| certificate not trusted by " + truststore.get('usingTrustStore') + " |"
    # certificate keysize + date
    certificate_chain = vulnerability.find('certificateChain')
    certificates = certificate_chain.findall('certificate')
    for certificate in certificates:
        if certificate.get('position') == "leaf":
            # certificate keysize
            public_key_size = certificate.find('subjectPublicKeyInfo').find('publicKeySize')
            public_key_size_value = public_key_size.text
            if int(public_key_size_value) < 2048:
                certificate_problems = certificate_problems + "| low public keysize (" + public_key_size_value + ") |"
            # certificate date
            today = datetime.date.today()
            date_dict = {'Jan': 1, 'Feb': 2, 'Mar': 3, 'Apr': 4, 'May': 5, 'Jun': 6, 'Jul': 7, 'Aug': 8, 'Sep': 9, 'Okt': 10, 'Nov': 11, 'Dec': 12}
            not_after = certificate.find('validity').find('notAfter').text
            not_after_month, not_after_day, not_after_year = not_after[:3], not_after[4:6], not_after[16:20]
            not_after_date = datetime.date(int(not_after_year),date_dict[not_after_month] ,int(not_after_day))
            if not_after_date < today:
                certificate_problems = certificate_problems + "| certificate outdated (too old) |"
            not_before = certificate.find('validity').find('notBefore').text
            not_before_month, not_before_day, not_before_year =not_before[:3], not_before[4:6], not_before[16:20]
            not_before_date = datetime.date(int(not_before_year),date_dict[not_before_month] ,int(not_before_day))
            if not_before_date > today:
                certificate_problems = certificate_problems + "| certificate outdated (not yet valid) |"
            # weak public key signature algorithm
            signature_algorithm = certificate.find('signatureAlgorithm').text
            if "md5" in signature_algorithm:
                certificate_problems = certificate_problems + "| weak public key signature algorithm ("+signature_algorithm+") |"

        db_cursor.execute('''UPDATE hosts SET certificate=? WHERE ip=? AND port=?''', (certificate_problems, host_ip, host_port))
        #db_connection.commit()


def check_for_weakmedium_cipher_keysize(db_cursor, db_connection, host_ip, host_port, vulnerability):
    if vulnerability.get('isProtocolSupported') == "True":
        accepted_cipher_suites = vulnerability.find('acceptedCipherSuites').findall('cipherSuite')
        for cipher in accepted_cipher_suites:
            if int(cipher.get('keySize')) < 112:
                print("medium/low keysize cipher supported")
                # causes multiple unnecessary db writings, but does not matter for the final result
                db_cursor.execute('''UPDATE hosts SET weakmediumcipher=? WHERE ip=? AND port=?''', (True, host_ip, host_port))
                #db_connection.commit()
                break  # weak/medium keysize cipher support is only needed in one cipher

def check_for_rc4_support(db_cursor, db_connection, host_ip, host_port, vulnerability):
    if vulnerability.get('isProtocolSupported') == "True":
        accepted_cipher_suites = vulnerability.find('acceptedCipherSuites').findall('cipherSuite')
        for cipher in accepted_cipher_suites:
            if "RC4" in cipher.get('name'):
                # causes multiple unnecessary db writings, but does not matter for the final result
                db_cursor.execute('''UPDATE hosts SET rc4=? WHERE ip=? AND port=?''', (True, host_ip, host_port))
                #db_connection.commit()
                break  # rc4 cipher support is only needed in one cipher